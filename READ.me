Задание 1. 
Обнаружение копий себя в локальной сети
Разработать приложение, обнаруживающее копии себя в локальной сети с помощью обмена multicast UDP сообщениями. Приложение должно отслеживать моменты появления и исчезновения других копий себя в локальной сети и при изменениях выводить список IP адресов "живых" копий.

Адрес multicast-группы необходимо передавать параметром в приложение. Приложение должно поддерживать работу как в IPv4 так и в IPv6 сетях, выбирая протокол автоматически в зависимости от переданного адреса группы.

Задание 2.
Передача файла по TCP с подсчётом скорости передачи данных
Вам необходимо разработать протокол передачи произвольного файла с одного компьютера на другой, и написать клиент и сервер, реализующие этот протокол. Сервер также должен выводить скорость приёма данных от клиента.
1. Серверу передаётся в параметрах номер порта, на котором он будет ждать входящих соединений от клиентов.
2. Клиенту передаётся в параметрах относительный или абсолютный путь к файлу, который нужно отправить. Длина имени файла не превышает 4096 байт в кодировке UTF-8. Размер файла не более 1 терабайта.
3. Клиенту также передаётся в параметрах DNS-имя (или IP-адрес) и номер порта сервера.
4. Клиент передаёт серверу имя файла в кодировке UTF-8, размер файла и его содержимое. Для передачи используется TCP. Протокол передачи придумайте сами (т.е. программы разных студентов могут оказаться несовместимы).
5. Сервер сохраняет полученный файл в поддиректорию uploads своей текущей директории. Имя файла, по возможности, совпадает с именем, которое передал клиент. Сервер никогда не должен писать за пределы директории uploads.
6. В процессе приёма данных от клиента, сервер должен раз в 3 секунды выводить в консоль мгновенную скорость приёма и среднюю скорость за сеанс. Скорости выводятся отдельно для каждого активного клиента. Если клиент был активен менее 3 секунд, скорость всё равно должна быть выведена для него один раз. Под скоростью здесь подразумевается количество байтов переданных за единицу времени.
7. После успешного сохранения всего файла сервер проверяет, совпадает ли размер полученных данных с размером, переданным клиентом, и сообщает клиенту об успехе или неуспехе операции, после чего закрывает соединение.
8. Клиент должен вывести на экран сообщение о том, успешной ли была передача файла.
9. Все используемые ресурсы ОС должны быть корректно освобождены, как только они больше не нужны.
10. Сервер должен уметь работать параллельно с несколькими клиентами. Для этого необходимо использовать треды (POSIX threads или их аналог в вашей ОС). Сразу после приёма соединения от одного клиента, сервер ожидает следующих клиентов.
11. В случае ошибки сервер должен разорвать соединение с клиентом. При этом он должен продолжить обслуживать остальных клиентов.

Задание 3.
Чат-дерево v3.0
Разработать приложение для узла "надежной" сети для передачи текстовых сообщений. Узлы логически объединены в дерево, каждый узел может отправлять UDP сообщения только своим непосредственным соседям. Приложение принимает в качестве параметров собственное имя узла, процент потерь, собственный порт, а также опционально IP-адрес и порт узла, с которым нужно соединиться на старте (сделать его свом соседом в дереве). Приложение, которому не был передан IP адрес и порт узла-предка, становится отдельностоящим узлом дерева. Примеры запуска:

$ chat_node Вася 2001 30 # Узел с именем "Вася", потери 30%, отдельностоящий
$ chat_node Петя 2002 40 127.0.0.1 2001 # Узел с именем "Петя", потери 40%, соединяется с Васей
Сообщение, введенное в стандартный ввод на любом из узлов сети, передается на все остальные узлы дерева и выводится в стандартный вывод на каждом узле ровно один раз. Все сообщения идентифицируются с помощью GUID. Для обеспечения "надёжности" доставка сообщений должна быть подтверждена.

Для реализации требований, каждый узел может вести учёт отправленных и полученных сообщений, однако неограниченное расходование памяти не допускается.

Важно, что переотправка сообщений вследствие потерь не должна приводить к задержкам в доставке других сообщений, и не должна блокировать работу остальных функций программы.

При поступлении любого входящего сообщения, узел генерирует случайное число от 0 до 99 включительно. Если это число строго меньше, чем заданный в параметрах процент потерь, сообщение игнорируется полностью, имитируя сетевую потерю пакета. Это необходимо для тестирования надёжности доставки сообщений.

В любой момент времени любой узел может завершить работу или стать недоступен, тогда его узлы-соседи должны через заданный в программе таймаут перестать отправлять ему сообщения, и перестать считать его соседом. Причём дерево не должно развалиться: оставшиеся узлы должны перестроить связи между собой так, чтобы вновь получилось дерево. Для этого каждый узел выбирает для себя "заместителя" среди своих соседей и сообщает его IP-адрес и порт другим соседям. Перестроение дерева должно происходить независимо от того, происходила ли в этот момент передача текстовых сообщений между этими узлами.

Для простоты мы считаем, что выходить из строя узлы могут только по очереди, так что дерево успевает восстановиться. Также допускается потеря некоторых сообщений в момент, когда дерево перестраивается.

Задание 4.
Змейка по сети

Задание 5.
SOCKS-прокси
1. Необходимо реализовать прокси-сервер, соответствующий стандарту SOCKS версии 5.
2. В параметрах программе передаётся только порт, на котором прокси будет ждать входящих подключений от клиентов.
3. Из трёх доступных в протоколе команд, обязательной является только реализация команды 1 (establish a TCP/IP stream connection)
4. Поддержку аутентификации и IPv6-адресов реализовывать не требуется.
5. Для реализации прокси использовать неблокирующиеся сокеты, работая с ними в рамках одного треда. Дополнительные треды использовать не допускается. Соответственно, никаких блокирующихся вызовов (кроме вызова селектора) не допускается.
6. Прокси не должна делать предположений о том, какой протокол уровня приложений будет использоваться внутри перенаправляемого TCP-соединения. В частности, должна поддерживаться передача данных одновременно в обе стороны, а соединения должны закрываться аккуратно (только после того, как они больше не нужны).
7. В приложении не должно быть холостых циклов ни в каких ситуациях. Другими словами, не должно быть возможно состояние программы, при котором неоднократно выполняется тело цикла, которое не делает ни одной фактической передачи данных за итерацию.
8. Не допускается неограниченное расходование памяти для обслуживания одного клиента.
9. Производительность работы через прокси не должна быть заметно хуже, чем без прокси. Для отслеживания корректности и скорости работы можно глядеть в Developer tools браузера на вкладку Network.
10. Прокси должен поддерживать резолвинг доменных имён (значение 0x03 в поле address). Резолвинг тоже должен быть неблокирующимся. Для этого предлагается использовать следующий подход:
На старте программы создать новый UDP-сокет и добавить его в селектор на чтение
Когда необходимо отрезолвить доменное имя, отправлять через этот сокет DNS-запрос A-записи на адрес рекурсивного DNS-резолвера
В обработчике чтения из сокета обрабатывать случай, когда получен ответ на DNS-запрос, и продолжать работу с полученным адресом
Для получения адреса рекурсивного резолвера, а также для формирования и парсинга DNS-сообщений на Java предлагается использовать библиотеку dnsjava (для других языков найдите сами).
Для тестирования можно настроить любой Web-браузер на использование вашего прокси, и посещать любые веб-сайты, богатые контентом